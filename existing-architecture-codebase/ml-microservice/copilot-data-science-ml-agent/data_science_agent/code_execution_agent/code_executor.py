"""
Local code executor with safety controls.

Executes Python code generated by the LLM in a controlled environment.
"""
import ast
import sys
import io
import traceback
import contextlib
import warnings
from pathlib import Path
from typing import Dict, Any, List, Optional
import matplotlib
matplotlib.use('Agg')  # Non-interactive backend
import matplotlib.pyplot as plt

from .config import get_config

config = get_config()


class CodeExecutor:
    """
    Executes Python code safely with restricted imports and timeout.
    """

    def __init__(self):
        self.config = config
        self.allowed_imports = set(config.allowed_imports)
        self.disallowed_patterns = config.disallowed_code_patterns

    def execute(
        self,
        code: str,
        file_paths: Dict[str, str],
        context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Execute Python code with file paths and optional context.

        Args:
            code: Python code to execute
            file_paths: Dictionary mapping variable names to file paths
                       e.g., {"df1": "/path/to/file1.csv", "df2": "/path/to/file2.csv"}
            context: Optional additional context variables

        Returns:
            Dictionary with:
            - success: bool
            - output: str (stdout/stderr)
            - result: Any (value of last expression or 'result' variable)
            - plots: List[str] (paths to saved plot files)
            - error: Optional[str] (error message if failed)
            - variables: Dict[str, Any] (selected variables from execution namespace)
        """
        # Safety checks
        safety_check = self._check_code_safety(code)
        if not safety_check['safe']:
            return {
                'success': False,
                'error': f"Code safety check failed: {safety_check['reason']}",
                'output': '',
                'result': None,
                'plots': [],
            }

        # Prepare execution namespace
        namespace = self._prepare_namespace(file_paths, context)

        # Capture stdout/stderr
        stdout = io.StringIO()
        stderr = io.StringIO()

        plots = []
        result = None

        try:
            with contextlib.redirect_stdout(stdout), contextlib.redirect_stderr(stderr):
                # Suppress warnings
                warnings.filterwarnings('ignore')

                # Execute code
                exec(code, namespace)

                # Extract result (check for 'result' variable or use last expression)
                if 'result' in namespace:
                    result = namespace['result']

                # Save any open plots
                plots = self._save_plots()

            return {
                'success': True,
                'output': stdout.getvalue() + stderr.getvalue(),
                'result': self._serialize_result(result),
                'plots': plots,
                'error': None,
                'variables': self._extract_variables(namespace),
            }

        except Exception as e:
            error_msg = f"{type(e).__name__}: {str(e)}\n{traceback.format_exc()}"
            return {
                'success': False,
                'output': stdout.getvalue() + stderr.getvalue(),
                'result': None,
                'plots': plots,
                'error': error_msg,
            }

    def _check_code_safety(self, code: str) -> Dict[str, Any]:
        """
        Check if code is safe to execute.

        Returns:
            Dictionary with 'safe' (bool) and 'reason' (str)
        """
        # Check length
        lines = code.split('\n')
        if len(lines) > self.config.max_code_lines:
            return {
                'safe': False,
                'reason': f"Code too long: {len(lines)} lines (max {self.config.max_code_lines})"
            }

        # Check for disallowed patterns
        code_lower = code.lower()
        for pattern in self.disallowed_patterns:
            if pattern.lower() in code_lower:
                return {
                    'safe': False,
                    'reason': f"Disallowed pattern found: {pattern}"
                }

        # Parse AST to check imports
        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            return {
                'safe': False,
                'reason': f"Syntax error: {e}"
            }

        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    if alias.name not in self.allowed_imports:
                        return {
                            'safe': False,
                            'reason': f"Disallowed import: {alias.name}"
                        }
            elif isinstance(node, ast.ImportFrom):
                if node.module not in self.allowed_imports:
                    return {
                        'safe': False,
                        'reason': f"Disallowed import: {node.module}"
                    }

        return {'safe': True, 'reason': ''}

    def _prepare_namespace(
        self,
        file_paths: Dict[str, str],
        context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Prepare execution namespace with allowed imports and file loaders.
        """
        import pandas as pd
        import numpy as np
        import matplotlib.pyplot as plt
        import seaborn as sns
        from scipy import stats
        from sklearn import preprocessing, metrics
        import json

        namespace = {
            'pd': pd,
            'np': np,
            'plt': plt,
            'sns': sns,
            'stats': stats,
            'preprocessing': preprocessing,
            'metrics': metrics,
            'json': json,
        }

        # Load files into namespace
        for var_name, file_path in file_paths.items():
            try:
                if file_path.lower().endswith('.csv'):
                    namespace[var_name] = pd.read_csv(file_path)
                elif file_path.lower().endswith(('.xlsx', '.xls')):
                    namespace[var_name] = pd.read_excel(file_path)
                else:
                    print(f"Warning: Unsupported file type for {file_path}")
            except Exception as e:
                print(f"Warning: Could not load {file_path}: {e}")
                namespace[var_name] = None

        # Add context variables
        if context:
            namespace.update(context)

        return namespace

    def _save_plots(self) -> List[str]:
        """
        Save all open matplotlib figures to files.

        Returns:
            List of file paths
        """
        plot_files = []
        config.viz_output_dir.mkdir(parents=True, exist_ok=True)

        figures = [plt.figure(n) for n in plt.get_fignums()]

        for i, fig in enumerate(figures):
            filename = f"plot_{i}_{hash(fig) % 10000}.png"
            filepath = config.viz_output_dir / filename
            fig.savefig(filepath, dpi=100, bbox_inches='tight')
            plot_files.append(str(filepath))

        # Close all figures
        plt.close('all')

        return plot_files

    def _serialize_result(self, result: Any) -> Any:
        """
        Convert result to JSON-serializable format.
        """
        if result is None:
            return None

        import pandas as pd
        import numpy as np

        if isinstance(result, pd.DataFrame):
            return {
                'type': 'dataframe',
                'shape': result.shape,
                'columns': list(result.columns),
                'data': result.head(100).to_dict(orient='records'),
                'truncated': len(result) > 100,
            }
        elif isinstance(result, pd.Series):
            return {
                'type': 'series',
                'length': len(result),
                'data': result.head(100).to_dict(),
                'truncated': len(result) > 100,
            }
        elif isinstance(result, np.ndarray):
            return {
                'type': 'ndarray',
                'shape': result.shape,
                'dtype': str(result.dtype),
                'data': result.tolist() if result.size < 1000 else result.flat[:1000].tolist(),
                'truncated': result.size > 1000,
            }
        elif isinstance(result, (list, dict, str, int, float, bool)):
            return result
        else:
            return str(result)

    def _extract_variables(self, namespace: Dict[str, Any]) -> Dict[str, Any]:
        """
        Extract relevant variables from execution namespace.

        Only includes variables created by the code, not built-ins.
        """
        import pandas as pd
        import numpy as np

        excluded = {
            'pd', 'np', 'plt', 'sns', 'stats', 'preprocessing',
            'metrics', 'json', '__builtins__', '__name__', '__doc__'
        }

        variables = {}
        for name, value in namespace.items():
            if name.startswith('_') or name in excluded:
                continue

            if isinstance(value, (pd.DataFrame, pd.Series)):
                variables[name] = {
                    'type': type(value).__name__,
                    'shape': getattr(value, 'shape', None),
                }
            elif isinstance(value, np.ndarray):
                variables[name] = {
                    'type': 'ndarray',
                    'shape': value.shape,
                    'dtype': str(value.dtype),
                }
            elif isinstance(value, (int, float, str, bool, list, dict)):
                variables[name] = value

        return variables
